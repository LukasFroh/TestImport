%% ###########################################################################################################################
%   repository: seastate module
%   author: ©Lukas Froehling (froehling@lufi.uni-hannover.de)
%   Master script
%  ###########################################################################################################################

function seastateMasterFnc(dataPath, headerPath, coastlinePath, wamDataPath, siteOverviewPath, logPath, figPath, expDataPath, ... % Path input
    site2Imp, seastateVars2Eval, minQF,...                                          % Seastate input
    wamModel2Eval, wamVars, ...                                                     % WAM input
    latLimMin, latLimMax, lonLimMin, lonLimMax, rasterSizeLat, rasterSizeLon, ...   % Spatial settings
    gshhgInputFile, ...                                                             % Coastline settings
    var2ScaleInsitu, var2ScaleWam, interpLineLength, ...                            % Scale settings
    cbType, pltType, figRes, figType, gridType, ...                                 % Plot settings
    timeShift )                                                                     % Manual time shift in hours as double (only for LuFI testing purposes)

tic

%% :::::::::| Structuring input vars in structs |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% Paths
eval(['paths.dataPath = char(' dataPath ');'])                  % Path to insitu data directory
eval(['paths.headerPath = char(' headerPath ');'])              % Path to header files
eval(['paths.coastlinePath = char(' coastlinePath ');'])        % Path to coastline data (GSHHG)
eval(['paths.wamDataPath = char(' wamDataPath ');'])            % Path to WAM raw data
eval(['paths.siteOverviewPath = char(' siteOverviewPath ');'])  % Path to siteOverview excel
eval(['paths.logPath = char(' logPath ');'])                    % Path to log files
eval(['paths.figPath = char(' figPath ');'])                    % Path to figure folder
eval(['paths.expDataPath = char(' expDataPath ');'])            % Path to export folder
% Input
eval(['input.site2imp   =' site2Imp ';'])                       % Which insitu sites should be considered?
eval(['input.seastateVars2Eval =' seastateVars2Eval ';'])       % Which insitu seaste variable should be imported (as Cellstring, default: 'VHM0')
input.minQF             = str2double(minQF);                    % Minimum final quality flag for insitu seastate data (Default: 1)
input.wamModel2Eval     = wamModel2Eval;                        % Specify WAM dataset. Choose between <'cwam'> and <'ewam'>
eval(['input.wamVars    =' wamVars ';'])                        % Set wam variables that should be imported (Cellstring). Choose between {'energy_per','mean_wave_dir','sea_dir','sea_mean_per','sea_peak_per','sea_whight','sign_whight','swell_dir','swell_mean_per','swell_peak_per','swell_whight','wind_dir','wind_speed'}
input.latLim            = [str2double(latLimMin), str2double(latLimMax)]; % Set latitude boundaries as min/max vector
input.lonLim            = [str2double(lonLimMin), str2double(lonLimMax)]; % Set longitude boundaries as min/max vector
input.rasterSize        = [str2double(rasterSizeLon),str2double(rasterSizeLat)]; % Set latitude/longitude resolution

% GSHHG Coastline dataset. Choose between <'gshhs_c.b'> (crude), <'gshhs_l.b'> (low), <'gshhs_i.b'> (intermediate), <'gshhs_h.b'> (high), <'gshhs_f.b'> (full, default option)
% Wessel, P., & Smith, W. H. F. (1996). A global, self-consistent, hierarchical, high-resolution shoreline database. In Journal of Geophysical Research: Solid Earth (Vol. 101, Issue B4, pp. 8741–8743). American Geophysical Union (AGU). https://doi.org/10.1029/96jb00104
GSHHG.filename          = gshhgInputFile;
eval(['var2ScaleInsitu  =' var2ScaleInsitu ';'])
eval(['var2ScaleWam  =' var2ScaleWam ';'])
% eval(['interpLineLength =' interpLineLength ';'])
interpLineLength        = str2double(interpLineLength);
eval(['GSHHG.filename = char(' gshhgInputFile ');'])
figRes                  = str2double(figRes);
timeShift               = str2double(timeShift);

% Which insitu data should be imported and considered? Choose between <true> and <false>
bools.boolDwrHIS        = true;
bools.boolDwrHIW        = true;
bools.boolDwrGPS        = true;
bools.boolRadac         = true;
bools.boolRadacSingle   = true;

% Current date and time
tNow                    = datetime('now','TimeZone','UTC');
tNowShifted             = dateshift(tNow,'start','hour');
if minute(tNow) > 30
    tNowShifted         = tNowShifted + minutes(30);
end

% Manual adjustment (newest files only up to 23:59 of day before)
tNowShifted             = tNowShifted - hours(timeShift);

input.dateIn            = datenum(tNowShifted);
input.dateOut           = datenum(tNowShifted);
input.timestep          = minutes(120);
input.time2Eval         = tNowShifted;
input.timeThresh        = 120;
input.interpMethod      = 'linear';

%% :::::::::| Initialize log file |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
logFileName             = strcat(datestr(tNowShifted,'yyyy_mm_dd_HH_MM_SS'),'_log.out');
cd(paths.logPath)
diary(logFileName)

%% :::::::::| Import insitu data |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% Import siteOverview csv
input.siteOverviewInit  = readtable(fullfile(paths.siteOverviewPath,'siteOverview.xlsx'));
input.validSiteIdx      = ismember(input.siteOverviewInit.name,input.site2imp);
input.siteOverview      = input.siteOverviewInit(input.validSiteIdx,:);

siteData                = imp_importMasterFunc(paths,input,bools);

% Check most recent file times
fileTimesMR             = [siteData(:).timeMostRecent];
mostRecentTime          = max(fileTimesMR);
disp(['Current time: ' datestr(tNow,'yyyy-mm-dd HH:MM:SS')])
disp(['Seastate map creation for time: ',datestr(tNowShifted,'yyyy-mm-dd HH:MM:SS')])
timeGap             = mostRecentTime - tNowShifted;
disp(['Time to most recent insitu files: '])
disp(timeGap)

% Stop script and give error message in case now seastate data is available for the last 30 minutes
if timeGap < -duration(minutes(30))
    error(['Execution stopped. No insitu seastate data for the last 30 minutes available. Time to most recent insitu files: ' num2str(hours(timeGap)) 'h.' ])
end

% Display which WAM model is used
disp(['Chosen numerical forecast model: ' upper(input.wamModel2Eval) ])

% Display which insitu sites are considered
disp('Following insitu sites are considered:')
disp(input.site2imp)
disp('No data available for sites:')
disp(input.site2imp(fileTimesMR < tNowShifted))

%% :::::::::| Import GSHHG data |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

% Access to mapping toolbox 
if license('test','MAP_Toolbox')
    [GSHHG.sets, GSHHG.lat, GSHHG.lon] = OR_GetCoastlines(paths.coastlinePath,GSHHG.filename,input.latLim,input.lonLim);                                  % Function to import
    % Create cellstr with fieldnames
    GSHHG.clFieldnames                 = fieldnames(GSHHG.sets);
    % No access to mapping toolbox
else
    % Instead: Load already imported GSHHG struct:
    s                   = load(fullfile(paths.coastlinePath,GSHHG.filename));
    % Name of imported struct;
    sFN                 = fieldnames(s);
    % Set GSHHG as struct name
    GSHHG               = s.(sFN{1});
end

%% :::::::::| Import wam data |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% Create lon/lat vector and grid
input.evalLonVec        = linspace(input.lonLim(1),input.lonLim(end),input.rasterSize(1));
input.evalLatVec        = linspace(input.latLim(1),input.latLim(end),input.rasterSize(2));
[input.evalLonGrid,input.evalLatGrid]  = meshgrid(input.evalLonVec,input.evalLatVec);
% Import wam files
[spatialData.wamfileList,spatialData.gridData,spatialData.wamRawParameters,spatialData.wamInterpParameters] = wamImport(input,paths);

%% :::::::::| Extract site data from spatial dataset |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
for i = 1:numel(input.site2imp)
    siteData        = OR_extractSiteDataFromWAM(siteData,spatialData,i);
end

%% :::::::::| Calculate scale data |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% Calculate scale data for each site and connection lines with interpolated scale values
siteData                = OR_CalculateScaleData(siteData,interpLineLength,var2ScaleInsitu,var2ScaleWam);
% Calculate scale matrix for whole area
spatialData         = OR_CalculateScaleMatrix(spatialData,siteData,GSHHG);
% Create scaled griddata for chosen variable
spatialData         = OR_ScaleWAMdata(spatialData,var2ScaleWam);

%% :::::::::| Plot Seastate |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% Plot Seastate map. Output based on plot type <pltType> and colorbar scaling <cbType>
disp('Chosen plotting options:')
disp(['Plot type: <', pltType, '>'])
disp(['Parameter range: <', cbType, '>'])
[lonGrid,latGrid,adjVarGrid,~] = plt_seastateModule(input,GSHHG,spatialData,siteData,pltType,cbType,gridType);

% Safe figure
figName = [datestr(input.time2Eval,'yyyymmdd_HHMM'), '_seastate_', pltType, figType];
exportgraphics(gcf,fullfile(paths.figPath,figName),'Resolution',figRes)


%% :::::::::| Save output |::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% Export adjusted spatial data
expData.date = input.time2Eval;
expData.lonGrid = lonGrid;
expData.latGrid = latGrid;
expData.adjVarGrid = adjVarGrid;

expFileName = [datestr(input.time2Eval,'yyyymmdd_HHMM'),'_data.mat'];
save(fullfile(paths.expDataPath,expFileName),"expData")
disp(['File <', expFileName, '> exported.'])

close all

% End time tracking
toc

diary off

